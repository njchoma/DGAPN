---
title: "IDR Docking Scores"
author: "Andrew Chen"
date: "7/17/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(idr)
library(reticulate)
use_condaenv("r-reticulate")
```

>Lack of consistency in virtual screening and structure reproduction results is the Achilles' heel of docking programs. They tend to do very well on some systems and terribly on others. The worst virtual screening method (measured by AUC) is on average only slightly better than random; nevertheless, it is expected to outperform the best virtual screening method (measured by AUC) 1 in 7 times. (FRED Pose Prediction and Virtual Screening Accuracy)


- FRED: Score is an estimate of Binding Affinity. 
- Autodock Vina. Score is an estimate of Binding Affinity.
- DOCK6. Dock Score is an estimate of approximate binding energy (more positive indicates better binding.)

### Importing Data

```{python}
import pandas as pd
import glob
from functools import reduce

#Find all targets that have data from three pipelines. There should only be 7. 
docking_scores_path = "/Users/ADChen/Downloads/DockingScores"
results_paths = glob.glob("/Users/ADChen/Downloads/DockingScores/*/*.results.txt")
targets = list(set([path.split(".")[0].split("/")[-1] for path in results_paths]))
match_targets = [i for i in targets if len(glob.glob(docking_scores_path+"/*/*"+i+"*")) == 3]

data_dict = {}
for i in match_targets:
  #Vina has an unused footer
  vina = pd.read_csv(docking_scores_path + "/vina/"+i+".vina.results.txt", sep = "\t", names = ["Title", "Score_vina"], skipfooter = 1)
  vina["rank_vina"] = vina["Score_vina"].rank(ascending = False)
  
  #Fred has an existing header
  fred = pd.read_csv(docking_scores_path + "/fred/"+i+".fred.results.txt", sep = "\t",  header = 0, names = ["Title", "Score_fred"])
  fred["rank_fred"] = fred["Score_fred"].rank(ascending = False)

  dock = pd.read_csv(docking_scores_path + "/dock6/"+i+".dock6.results.txt", sep = "\t",  names = ["Title", "Score_dock"])
  dock["rank_dock"] = dock["Score_dock"].rank(ascending = True)
  
  if i == "NSP15_6W01_AB_1_F":
    qvina = pd.read_csv(docking_scores_path+"/NSP15_6w01_AB_Mcule.qvina.results.txt", header = 0, names = ["Title", "Score_qvina"])
    qvina["rank_qvina"] = qvina["Score_qvina"].rank(ascending = False)
    data_frames = [vina, fred, dock, qvina]
  else:
    data_frames = [vina, fred, dock]

  data_dict[i] = reduce(lambda left,right: pd.merge(left,right, on = ['Title'], how = 'inner'), data_frames)

  print(i, vina.shape, fred.shape, dock.shape, data_dict[i].shape)

#Some targets do not have enough data.
data_dict = {k:v for k,v in data_dict.items() if v.shape[0]>2000}
```


### Pair Plots of Ranks
```{r}
names <- names(py$data_dict)
data_list <- lapply(py$data_dict, py_to_r)

for (i in 1:4){
  if(names[i] == "NSP15_6W01_AB_1_F"){
    pairs(data_list[[i]][c(3,5,7,9)],pch=20, main = names[i])
  } else {
    pairs(data_list[[i]][c(3,5,7)],pch=20, main = names[i])
  }
}

```

### IDR

```{r}
mu <- 2.6
sigma <- 2.5
rho <- 0.3
p <- 0.1
IDR.level <- 0.01

idrs <- list()
obs <-list()
for (i in 1:4){
  if(names[i] == "NSP15_6W01_AB_1_F"){
    idr.out <- est.IDR(data_list[[i]][c(3,5,7,9)], mu, sigma, rho, p, eps=0.001, max.ite=20)
    obs.selected <- select.IDR(data_list[[i]][c(3,5,7,9)], idr.out$IDR, IDR.level)
    
  } else {
    idr.out <- est.IDR(data_list[[i]][c(3,5,7)], mu, sigma, rho, p, eps=0.001, max.ite=20)
    obs.selected <- select.IDR(data_list[[i]][c(3,5,7)], idr.out$IDR, IDR.level)
  }
  idrs[[names[i]]] <- idr.out
  obs[[names[i]]] <- obs.selected

}
rm(idr.out, obs.selected)
```

### Diagnostics
- Filter by top 5% and color on pair plots. 
- Make collated csv.
- Check if any chemicals appear in top 5% for two or more targets.

```{r}
# Top5% IDR
top <- list()
top_mols <- list()
for (i in 1:4){
  top[[names[i]]] <- which(idrs[[i]]$IDR < 0.05)
  top_mols[[names[i]]] <- data_list[[names[i]]]['Title'][top[[names[i]]],]
}

```

```{r}
for (i in 1:4){
  rank_cols <- character(nrow(data_list[[i]]))
  rank_cols[] <- "black"
  rank_cols[top[[i]]] <- "red"
  jpeg(file = paste(names[[i]], ".jpg", sep = ""))
  
  if(names[i] == "NSP15_6W01_AB_1_F"){
      pairs(data_list[[i]][c(3,5,7,9)], col = rank_cols, pch = 20, main = names[[i]])
  } else {
      pairs(data_list[[i]][c(3,5,7)], col = rank_cols, pch = 20, main = names[[i]])
  }
  
  dev.off()
}
```

### Molecules that bind to several targets well

```{python}
import itertools
from operator import and_
import pandas as pd

df = pd.DataFrame(columns = ['Interaction', 'Molecules'])

def common_member(*args): 
    data = []
    for arg in args:
      data.append(set(arg))
  
    if reduce(and_, data):
      return reduce(and_, data)
    else: 
      return 0
        
print("Two targets:")
for i in list(itertools.combinations(r.top_mols,2)):
  row = {'Interaction':i, 'Molecules': common_member(r.top_mols[i[0]], r.top_mols[i[1]])}
  df = df.append(row, ignore_index = True)
  #print(i, common_member(r.top_mols[i[0]], r.top_mols[i[1]]))

print("Three targets:")
for i in list(itertools.combinations(r.top,3)):
  row = {'Interaction':i, 'Molecules': common_member(r.top_mols[i[0]], r.top_mols[i[1]], r.top_mols[i[2]])}
  df = df.append(row, ignore_index = True)
  #print(i, common_member(r.top_mols[i[0]], r.top_mols[i[1]], r.top_mols[i[2]]))
  
print("Four targets:")
for i in list(itertools.combinations(r.top,4)):
  row = {'Interaction':i, 'Molecules': common_member(r.top_mols[i[0]], r.top_mols[i[1]], r.top_mols[i[2]], r.top_mols[i[3]])}
  df = df.append(row, ignore_index = True)
  #print(i, common_member(r.top_mols[i[0]], r.top_mols[i[1]], r.top_mols[i[2]], r.top_mols[i[3]]))
  
df.to_csv("multiple_targets.csv",index = False)
```


### Export IDR Data

```{r}
for (i in 1:4){
  data_list[[i]]["local_idr"] <- idrs[[i]]$idr
  data_list[[i]]["global_idr"] <- idrs[[i]]$IDR
  
  write.table(data_list[[i]], file = paste(names[i],".csv", sep = ""), sep = ",", row.names = FALSE)
}
```

